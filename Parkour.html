<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Platform Game</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: Arial, sans-serif;
    }
    canvas { 
      display: block; 
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 5px;
      font-size: 14px;
    }
    canvas {
      cursor: default;
    }
  </style>
</head>

<body>
  <div id="info">
    <strong>Controls:</strong><br>
    WASD - Move<br>
    Space - Jump<br>
    Tab - Toggle First-Person (pointer lock & mouse look)<br>
    Esc - Release pointer lock / exit FPS
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    let scene
    let camera 
    let renderer
    let player
    let ground
    let platforms = [];
    let keys = {};
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let canJump = false;
    const GRAVITY = -30;
    const JUMP_FORCE = 15;
    const MOVE_SPEED = 20;
    const PLAYER_HALF_HEIGHT = 1; // player box height is 2, so half is 1

    // FPS / pointer-lock related
    let isFPS = false;
    let yaw = 0;   // rotation around Y
    let pitch = 0; // rotation around X
    const MOUSE_SENSITIVITY = 0.0025;

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 0, 100);

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 15, 20);
      camera.lookAt(0, 0, 0);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.3);
      dirLight.position.set(5, 10, 5);
      dirLight.castShadow = true;
      dirLight.shadow.camera.left = -20;
      dirLight.shadow.camera.right = 20;
      dirLight.shadow.camera.top = 20;
      dirLight.shadow.camera.bottom = -20;
      scene.add(dirLight);

      // Ground
      const groundGeo = new THREE.BoxGeometry(50, 1, 50);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x2d5016 });
      ground = new THREE.Mesh(groundGeo, groundMat);
      ground.receiveShadow = true;
      ground.position.y = -0.5;
      scene.add(ground);

      // Player (cube character)
      const playerGeo = new THREE.BoxGeometry(1, 2, 1);
      const playerMat = new THREE.MeshStandardMaterial({ color: 0xff4444 });
      player = new THREE.Mesh(playerGeo, playerMat);
      player.castShadow = true;
      player.position.set(0, 3, 0);
      scene.add(player);

      // Create platforms
      const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x8B5A2B });
      function createPlatform(x, z, width, depth, centerY) {
        const geo = new THREE.BoxGeometry(width, 1, depth); // fixed thickness = 1
        const mesh = new THREE.Mesh(geo, platformMaterial);
        mesh.receiveShadow = true;
        mesh.position.set(x, centerY, z);
        scene.add(mesh);
        platforms.push(mesh);
      }

      // Several example platforms (x, z, width, depth, centerY)
      createPlatform(0, -8, 6, 6, 2.5);
      createPlatform(7, -2, 4, 4, 4.0);
      createPlatform(-7, 3, 3, 6, 6.0);
      createPlatform(10, 8, 8, 3, 3.5);
      createPlatform(-12, -6, 5, 5, 5.5);
      createPlatform(3, 12, 6, 6, 8.0);

      // Event listeners
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
      window.addEventListener('resize', onWindowResize);

      // Pointer lock change / error
      document.addEventListener('pointerlockchange', onPointerLockChange);
      document.addEventListener('pointerlockerror', () => {
        console.warn('Pointer lock error');
      });

      // Mouse look (activated only while pointer locked)
      document.addEventListener('mousemove', onMouseMove);
    }

    function onKeyDown(e) {
      // Toggle FPS with Tab
      if (e.key === 'Tab') {
        e.preventDefault();
        // If not currently pointer locked, request it to enter FPS
        if (document.pointerLockElement !== renderer.domElement) {
          renderer.domElement.requestPointerLock();
          // isFPS will be set when pointerlockchange fires
        } else {
          // If pointer is locked, exit pointer lock to return to 3rd-person
          document.exitPointerLock();
        }
        return;
      }

      // Normal movement keys
      keys[e.key.toLowerCase()] = true;
    }

    function onPointerLockChange() {
      const locked = document.pointerLockElement === renderer.domElement;
      isFPS = locked;
      if (!isFPS) {
        // Reset pitch/yaw? Keep them, but you might want to reset if desired
      } else {
        // When entering FPS, derive current yaw from camera orientation so it's smooth
        const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
        yaw = euler.y;
        pitch = euler.x;
        // Hide cursor handled by pointer lock automatically
      }
    }

    function onMouseMove(e) {
      if (!isFPS) return;
      // movementX/Y are available when pointer is locked
      const movementX = e.movementX || 0;
      const movementY = e.movementY || 0;
      yaw -= movementX * MOUSE_SENSITIVITY;
      pitch -= movementY * MOUSE_SENSITIVITY;
      // Clamp pitch so you can't flip upside down
      const PI_2 = Math.PI / 2 - 0.05;
      pitch = Math.max(-PI_2, Math.min(PI_2, pitch));
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function checkPlatformCollisions() {
      // simple AABB collision checks for landing on top of platforms while falling
      const EPS = 0.05;
      const playerBottom = player.position.y - PLAYER_HALF_HEIGHT;

      for (let p of platforms) {
        // geometry.parameters exists for BoxGeometry created directly
        const halfW = (p.geometry.parameters.width) / 2;
        const halfD = (p.geometry.parameters.depth) / 2;
        const topY = p.position.y + (p.geometry.parameters.height) / 2; // height = 1 => top = center + 0.5

        // check XZ overlap
        const withinX = player.position.x > (p.position.x - halfW) && player.position.x < (p.position.x + halfW);
        const withinZ = player.position.z > (p.position.z - halfD) && player.position.z < (p.position.z + halfD);

        // Only consider landing if player is over platform horizontally and falling (or stationary vertically)
        if (withinX && withinZ && velocity.y <= 0) {
          // If player's bottom is at or just below the platform top (within EPS)
          if (playerBottom <= topY + EPS && (playerBottom >= topY - 2)) {
            // Snap to platform top
            player.position.y = topY + PLAYER_HALF_HEIGHT;
            velocity.y = 0;
            canJump = true;
            return; // landed on a platform; no need to check others this frame
          }
        }
      }
    }

    function updatePlayer(delta) {
      // Apply gravity
      velocity.y += GRAVITY * delta;

      // Movement directions
      direction.set(0, 0, 0);

      if (keys['w']) direction.z -= 1;
      if (keys['s']) direction.z += 1;
      if (keys['a']) direction.x -= 1;
      if (keys['d']) direction.x += 1;

      if (isFPS) {
        // Camera-relative movement (use yaw to compute forward/right)
        if (direction.length() > 0) {
          const moveX = direction.x;
          const moveZ = direction.z;
          // forward vector (camera facing direction). For yaw=0 we want forward = (0,0,-1)
          const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
          const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));
          const moveDir = new THREE.Vector3();
          moveDir.addScaledVector(forward, moveZ);
          moveDir.addScaledVector(right, moveX);
          if (moveDir.length() > 0) moveDir.normalize();
          velocity.x = moveDir.x * MOVE_SPEED;
          velocity.z = moveDir.z * MOVE_SPEED;
        } else {
          velocity.x *= 0.9;
          velocity.z *= 0.9;
        }
      } else {
        // World-axis movement (original behaviour)
        if (direction.length() > 0) {
          direction.normalize();
          velocity.x = direction.x * MOVE_SPEED;
          velocity.z = direction.z * MOVE_SPEED;
        } else {
          velocity.x *= 0.9;
          velocity.z *= 0.9;
        }
      }

      // Jump
      if ((keys[' '] || keys['space']) && canJump) {
        velocity.y = JUMP_FORCE;
        canJump = false;
      }

      // Update position
      player.position.x += velocity.x * delta;
      player.position.z += velocity.z * delta;
      player.position.y += velocity.y * delta;

      // Platform collision check (should happen before ground collision)
      checkPlatformCollisions();

      // Ground collision
      if (player.position.y <= 1) {
        player.position.y = 1;
        velocity.y = 0;
        canJump = true;
      }

      // Keep player in bounds
      player.position.x = Math.max(-24, Math.min(24, player.position.x));
      player.position.z = Math.max(-24, Math.min(24, player.position.z));

      // Rotate player mesh to face yaw (so third-person view also shows orientation)
      player.rotation.y = yaw;
    }

    function updateCamera() {
      if (isFPS) {
        // Place camera at player's head and apply yaw/pitch
        const headHeight = PLAYER_HALF_HEIGHT * 0.9 + 0.1; // around player's eye level
        camera.position.set(player.position.x, player.position.y + headHeight, player.position.z);
        // Set camera quaternion from yaw/pitch (order Y then X)
        const quat = new THREE.Quaternion();
        quat.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
        camera.quaternion.copy(quat);
      } else {
        // third-person: camera follows behind the player smoothly and orients to look at the player
        // Desired offset in local player space: up and back
        const localOffset = new THREE.Vector3(0, 6, 12); // y up, z back
        // Rotate offset by player's yaw so camera stays behind relative to player's facing direction
        const quat = new THREE.Quaternion();
        quat.setFromEuler(new THREE.Euler(0, player.rotation.y, 0));
        const worldOffset = localOffset.clone().applyQuaternion(quat);
        const desiredPos = new THREE.Vector3().copy(player.position).add(worldOffset);
        // Smoothly interpolate camera position
        camera.position.lerp(desiredPos, 0.08);
        // Look slightly above player's position (eyes)
        const lookAtPos = new THREE.Vector3(player.position.x, player.position.y + 1.2, player.position.z);
        camera.lookAt(lookAtPos);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      
      const delta = 0.016; // Approximately 60fps
      updatePlayer(delta);
      updateCamera();
      
      renderer.render(scene, camera);
    }

    init();
    animate();
  </script>
</body>
</html>
